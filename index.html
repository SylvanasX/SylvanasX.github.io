<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SylvanasX">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/30/Swift%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%80%86%E5%8F%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SylvanasX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/Swift%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%80%86%E5%8F%98/" class="post-title-link" itemprop="url">Swift 函数式编程:逆变</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-30 14:13:52 / Modified: 14:14:36" itemprop="dateCreated datePublished" datetime="2021-01-30T14:13:52+08:00">2021-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Swift-函数式编程-逆变"><a href="#Swift-函数式编程-逆变" class="headerlink" title="Swift 函数式编程:逆变"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rz411e7xw/">Swift 函数式编程:逆变</a></h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/25/172e9c5d174e554f?w=1802&h=1020&f=png&s=235910"></p>
<ul>
<li>介绍了逆变协变，主要是逆变</li>
<li>逆变或协变的场景</li>
<li>向前组合函数，逆变在编程中的使用</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rz411e7xw/">点击这里前往观看</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/30/App%20%E6%B8%A0%E9%81%93%E8%BF%BD%E8%B8%AA%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SylvanasX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/App%20%E6%B8%A0%E9%81%93%E8%BF%BD%E8%B8%AA%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">App 渠道追踪概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-30 14:12:47 / Modified: 14:13:04" itemprop="dateCreated datePublished" datetime="2021-01-30T14:12:47+08:00">2021-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>渠道分发都有跳转到 App Store 这一步，而 Apple 本身是不会提供太多信息给开发者的。所以，对于整个流程的三个步骤：在某个渠道点击下载链接并跳转到 App Store -&gt; App Store 内下载 App -&gt; 用户激活 App 中的第二步，是一个完全的黑盒，所以，没有办法精确地追踪一个用户在这三个步骤中的轨迹。</p>
<ul>
<li>场景：<br>  用户在网页上进行用户行为，产生了数据，然后下载了 App,当用户打开 App 的时候，希望知道渠道来源，并延续在网页上的行为和数据。</li>
<li>例子：<br>  用户在 App 里面的浏览器访问了某个页面，被引导下载了 App, 等用户下载完成，打开 App 的时候，甚至能同步刚才在页面上的一些数据。<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172e091ffd49436e?w=1240&h=613&f=png&s=144096"></p>
<ul>
<li>用户访问落地页 URL, 如 <code>https://xxx/yyy?channelCode=23901&amp;testKey=testValue</code>, 并带上设备指纹数据渠道号放在URL中，业务参数等自定义参数放在 Body 中，向服务端请求 token</li>
<li>用户点击下载按钮，复制 token 到粘贴板，使用到零宽度字符隐藏 token，是 iOS 则写 Cookie(SFSafariViewController iOS 9.x.x)</li>
<li>H5 重定向到 App Store,用户下载，安装 App</li>
<li>安装完成，用户打开 App,检测剪贴板是否有 token, 上报 token 和 设备指纹，iOS 9.x.x 尝试读 Cookie</li>
<li>后端检验 token,渠道来源</li>
<li>服务端返回参数</li>
</ul>
<p>有些情况会导致剪贴板没有数据（系统版本或用户覆盖剪贴板），所以通过收集设备的多维信息屏幕尺寸，操作系统，IP,手机型号, 访问时间等设备指纹信息，综合作为”唯一标识”（设备指纹），一种互补的方法。</p>
<h3 id="各端处理"><a href="#各端处理" class="headerlink" title="各端处理"></a>各端处理</h3><p>前端：<br>提供对应的 Web SDK 方便集成,在进入 H5 页，获取</p>
<ul>
<li>屏幕高度 (window.screen.height)</li>
<li>屏幕宽度 (window.screen.width)</li>
<li>设备像素比 (window.devicePixelRatio)</li>
<li>IP (服务端)</li>
<li>设备类型 (iPhone | iPad | iPod | Android) 等</li>
<li>系统版本号 （12.2）</li>
<li>访问时间(服务端)</li>
</ul>
<p>等参数包含在 URL 中，自定义参数用 Body，请求成功返回 token,点击跳转 App Store 时，复制 token 到剪贴板。</p>
<p>客户端：<br>获取剪贴板数据和设备指纹数据，请求渠道来源和自定义参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;channelCode&quot;: &quot;&quot;,</span><br><span class="line">	&quot;data&quot;: &#123;</span><br><span class="line">		&quot;action&quot;: &quot;&quot;,</span><br><span class="line">		&quot;extend&quot;: &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端：<br>服务端校验 token 的合法性，以及渠道来源，如果没有获取到 token, 或 iOS &lt;=9.x.x 不支持 JS 操作剪贴板，所以这个时候，采用设备指纹作为“唯一标识”，判断来源。最后返回自定义参数,规则如下：</p>
<ul>
<li>获取在剪贴板能获取到 token, 就用 token 作为唯一标识</li>
<li>如果获取不到 token，就在设备指纹完全一致的情况下，加上一定时间内的限制，存在一定误差</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>涉及实现技术点：</p>
<ul>
<li>粘贴板，零宽度字符(用于隐藏粘贴板内容，用户不可见)</li>
<li>设备指纹，屏幕宽高、设备像素比、操作系统、操作系统版本、IP 和时间戳等</li>
<li>iOS SFSafariViewController，获取 Cookie</li>
</ul>
<p>通过渠道追踪，主要用于解决以下问题：</p>
<ul>
<li>运营活动效果分析：可用于统计分析不同的运营活动带来的新增用户数量、留存情况。为App精细化运营提供支持</li>
<li>H5页面操作延续功能：通过运营活动带来的App用户，在首次安装完成启动App，获取业务参数，可以延续之前H5页面的行为</li>
<li>新用户冷启动推荐辅助：将新用户在H5页面的操作轨迹提供给推荐算法，解决新用户冷启动精准推荐问题</li>
<li>社交分享效果统计：精确统计每个分享带来的App安装量及留存情况</li>
<li>App地推效果统计：通过二维码统计地推效果</li>
</ul>
<p>iOS 14 往粘贴板写内容，然后打开别的 App 会有相关提示了，所以这种用粘贴板的方式可能不太友好</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/30/Swift%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%86%85%E5%AE%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SylvanasX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/Swift%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%86%85%E5%AE%B9%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">Swift 函数式编程内容汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-30 14:11:04 / Modified: 14:11:46" itemprop="dateCreated datePublished" datetime="2021-01-30T14:11:04+08:00">2021-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>分享自己录制的关于 Swift 函数式编程的内容</li>
<li>观看后可以多多提出建议</li>
<li>以下是目前录制的内容</li>
</ul>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rz411e7xw/">Swift 函数式编程:逆变</a></p>
<ul>
<li><p>介绍了逆变协变，主要是逆变</p>
</li>
<li><p>参数什么情况是逆变或协变</p>
</li>
<li><p>向前组合函数，逆变在编程中的使用</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/25/172e9c5d174e554f?w=1802&h=1020&f=png&s=235910"></p>
</li>
</ul>
</li>
<li><p>Swift Parser 部分</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17k4y1z7V9">Swift Parser 7 Parser 组合2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ap4y1D7pD">Swift Parser 6 Parser 组合1</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kk4y1z7tu">Swift Parser 5 Parser Zip</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XT4y1u7yH">Swift Parser 4 Parser FlatMap</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Qp4y1Q7hr">Swift Parser 3 Parser Map</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iz411q7Rf">Swift Parser 2 定义更多 Parser</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rt4y117WS">Swift Parser 1 Parser 定义</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12K411W7ZS">Swift Parser 0 Parser 简绍</a> 这集刚开始录制，忘记去噪</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/28/172fac3aa5b1bb4b?w=1430&h=1416&f=png&s=278185"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/30/iOS%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%20+%20%E7%9B%91%E6%8E%A7%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SylvanasX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/iOS%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%20+%20%E7%9B%91%E6%8E%A7%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">iOS 启动优化 + 监控实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-30 14:07:50 / Modified: 14:09:55" itemprop="dateCreated datePublished" datetime="2021-01-30T14:07:50+08:00">2021-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58eefdbfedf?w=1240&h=496&f=png&s=92223"></p>
<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>距离上次启动优化（启动任务分级）相隔差不多2年时间了,虽然一直保持在之前的启动速度，但是每个版本排查启动增量会耗费不少时间,想做一个自动化的启动监控流程来降低这方面的时间成本，在启动监控开发中又发现部分启动可优化，于是就顺便把启动也优化了一下。</p>
<p>本文主要涉及以下几方面：</p>
<ul>
<li><strong>1、启动优化</strong>：启动流程、如何优化、push启动优化、二进制重排、后续计划</li>
<li><strong>2、自动化启动监控</strong><h1 id="二、成果"><a href="#二、成果" class="headerlink" title="二、成果"></a>二、成果</h1></li>
</ul>
<p><strong>1、启动优化</strong>：在iPhone8Plus上自测，从点击图标到首页图片完全加载由之前的1.2s减少到0.51s。测试同学分别在iPhone6和iPhone8上面验证，总启动耗时相比线上版本减少了 50%-60% 。</p>
<p><strong>2、启动监控</strong>：每晚固定的时间点，设备会自动启动应用10次，将启动数据上传并diff上一天的数据，将diff数据增量超标的方法通过邮件发送到代码提交者的邮箱，提示对应同学修改。</p>
<p>下图为8plus优化后的启动</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58ef078ea25?w=640&h=960&f=gif&s=5261585"></p>
<h1 id="三、优化思路"><a href="#三、优化思路" class="headerlink" title="三、优化思路"></a>三、优化思路</h1><h2 id="1、如何定义启动开始和结束时间？"><a href="#1、如何定义启动开始和结束时间？" class="headerlink" title="1、如何定义启动开始和结束时间？"></a>1、如何定义启动开始和结束时间？</h2><p>在做优化之前，需要将启动耗时的计算标准规范统一化，这样才好衡量启动耗时以及优化的效果。</p>
<h3 id="1-1-启动流程"><a href="#1-1-启动流程" class="headerlink" title="1.1 启动流程"></a>1.1 启动流程</h3><p>根据下图，定义出启动开始时间为用户点击icon，结束时间为首页数据展示完成</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58ef27a23dd?w=1240&h=697&f=png&s=208029"></p>
<h3 id="1-2-计算启动开始和结束时间"><a href="#1-2-计算启动开始和结束时间" class="headerlink" title="1.2 计算启动开始和结束时间"></a>1.2 计算启动开始和结束时间</h3><h4 id="1-2-1-测试标准："><a href="#1-2-1-测试标准：" class="headerlink" title="1.2.1 测试标准："></a>1.2.1 测试标准：</h4><p>使用录屏工具对app启动进行录制，通过QuickTime Plyaer的修剪功或将者视频解帧计算，以点击appicon变灰为启动开始时间、以首页图片完全展示为结束时间，计算两个时间的差即为总启动时间。</p>
<h4 id="1-2-2-代码如何统计："><a href="#1-2-2-代码如何统计：" class="headerlink" title="1.2.2 代码如何统计："></a>1.2.2 代码如何统计：</h4><ul>
<li><strong>启动时间</strong>：通过当前进程标识（NSProcessInfo\processIdentifier），读取进程信息内的进程创建时间(__p_starttime)为启动时间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (NSTimeInterval)processStartTime</span><br><span class="line">&#123;   &#x2F;&#x2F; 单位是毫秒</span><br><span class="line">    struct kinfo_proc kProcInfo;</span><br><span class="line">    if ([self processInfoForPID:[[NSProcessInfo processInfo] processIdentifier] procInfo:&amp;kProcInfo]) &#123;</span><br><span class="line">        return kProcInfo.kp_proc.p_un.__p_starttime.tv_sec * 1000.0 + kProcInfo.kp_proc.p_un.__p_starttime.tv_usec &#x2F; 1000.0;</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSAssert(NO, @&quot;无法取得进程的信息&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)processInfoForPID:(int)pid procInfo:(struct kinfo_proc*)procInfo</span><br><span class="line">&#123;</span><br><span class="line">    int cmd[4] &#x3D; &#123;CTL_KERN, KERN_PROC, KERN_PROC_PID, pid&#125;;</span><br><span class="line">    size_t size &#x3D; sizeof(*procInfo);</span><br><span class="line">    return sysctl(cmd, sizeof(cmd)&#x2F;sizeof(*cmd), procInfo, &amp;size, NULL, 0) &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>结束时间</strong>：以首页的所有图片全部加载完成为结束时间，hook图片下载方法，在启动完成前将所有调用该方法的url存入数组，图片下载完成之后移出数组，当数组内元素个数为0时，代表首页的图片下载完成，即为结束时间，以下为hook的伪代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)hook_setImageWithUrl:(NSString *)url completed:(completedBlock)completed</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 启动已经完成执行hook前逻辑</span><br><span class="line">    if (YYLaunchSteps.launchFinished) &#123;</span><br><span class="line">        [self hook_setimageWithUrl...];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [LaunchImageArray addobject:url];</span><br><span class="line">    completedBlock newCompletedBlock &#x3D; ^(...) &#123;</span><br><span class="line">        [LaunchImageArray removeObject:url];</span><br><span class="line">        if (LaunchImageArray.count &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 数组个数为0代表全部图片下载完成</span><br><span class="line">            YYLaunchSteps.launchFinished &#x3D; YES;</span><br><span class="line">        &#125;</span><br><span class="line">        if (completed) &#123;</span><br><span class="line">            completed(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [self hook_setImageWithUrl:url completed:newCompletedBlock];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、优化两步骤"><a href="#2、优化两步骤" class="headerlink" title="2、优化两步骤"></a>2、优化两步骤</h2><h3 id="2-1-找"><a href="#2-1-找" class="headerlink" title="2.1 找"></a>2.1 找</h3><p>根据启动流程，找出app启动时耗时较大的、启动流程中不需要的方法。</p>
<h3 id="2-2-改"><a href="#2-2-改" class="headerlink" title="2.2 改"></a>2.2 改</h3><p>对耗时较高的方法，进行耗时细分，寻找可优化部分，进行修改。对启动流程中不需要的方法，进行懒加载或者延后到启动完成之后执行。</p>
<h2 id="3、pre-main优化"><a href="#3、pre-main优化" class="headerlink" title="3、pre-main优化"></a>3、pre-main优化</h2><p>pre-main的整个流程可以看前面的图，已经有非常成熟且多的资料对这个流程进行了说明，这里就不重复了，总之这个阶段我们能做的有：</p>
<ul>
<li>1、Load dylibs阶段：减少或者合并dylibs，将动态库换成静态库。</li>
<li>2、Rebase/Bind阶段：减少类、方法、分类数量</li>
<li>3、Objc setup阶段：没啥可做的</li>
<li>4、Initializers阶段：优化+load方法、减少构造器函数（constructor），减少C++静态全局变量</li>
</ul>
<p>以上部分，其实在上一次启动优化（两年前）就已经做的差不多了（没有处理过的建议先处理一下），比如公司内部的sdk已经全部换成静态库了，category、load方法也处理过，删除无用类、方法、资源这个在很早以前做包体积优化的时候已经做得比较彻底了，并且现在也有一套自动化流程来管理每天包体积的增量，所以整个pre-main的启动优化能做的非常少，不过为了突破原有的优化过的速度，也做了一些苦力活，本身因为项目历史悠久，并且代码数量较大库较多，导致pre-main的整个耗时比较高，于是想衡量一下每个库的引入对整个项目的启动造成了多大的影响，通过创建一个新的工程，分别将podfile里面的库一个个的导入进新项目，然后大概的评估每个库带来的pre-main耗时，步骤就是：</p>
<p>首先在xcode设置环境变量 DYLD_PRINT_STATISTICS 为1，这个能输出pre-main的耗时，然后。</p>
<ul>
<li>1、podfile 添加 podA</li>
<li>2、pod update</li>
<li>3、重启设备（重要！），xcode运行新项目，记录pre-main耗时，比较未添加podA库时的耗时差值，然后重复1、2、3步骤，大概统计出每个库引入项目带来的pre-main耗时影响。</li>
</ul>
<p>得出每个库大概的耗时之后，我们评估出有一些库并不那么重要并且耗时达到几十毫秒的例如某Refresh库等（本身有一套类似逻辑），我们将它移除并且修改使用的部分。对耗时较高方便推动修改的库推动优化（不方便推动的去提需求容易被打，注意安全 ⚠️）这一步大概移除了3-5个库。</p>
<h2 id="4、main阶段优化"><a href="#4、main阶段优化" class="headerlink" title="4、main阶段优化"></a>4、main阶段优化</h2><p>main阶段的优化第一步找出可优化的任务，提供三种找的方式：</p>
<h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><p>通过走查代码，看哪些任务在整个启动链路上是不必要的,进行延后，使用插桩打点的方式通过NSLog输出每个方法执行后的时间统计每个方法的耗时，对耗时高的进行耗时细分，可拆解的进行拆解，可延后的进行延后。这个方案比较直接和简单，如果没有进行任务的优先级排序，这个方式也能加快启动速度，缺点就是无法找出一些依赖关系导致的一些不必要的任务执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过这个方式来统计每个方法同步的耗时</span><br><span class="line">CFAbsoluteTime start &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">[self doSomething];</span><br><span class="line">NSLog(@&quot;doSomething : %f&quot;,CFAbsoluteTimeGetCurrent() - start);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以在main函数调用的时候设置一个全局开始时间，</span><br><span class="line">&#x2F;&#x2F; 在其他类里面通过extern关键字取main的时间，如在main.m内:</span><br><span class="line">CFAbsoluteTime kAppStartTime;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    kAppStartTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; someClass.m</span><br><span class="line">extern CFAbsoluteTime kAppStartTime;</span><br><span class="line">CFAbsoluteTime duration &#x3D; (CFAbsoluteTimeGetCurrent() - kAppStartTime);</span><br></pre></td></tr></table></figure>
<h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><p>通过hook objc_msgSend方法，统计main–&gt;首页图片完全加载的所有方法以及耗时，按照火焰图需要的数据格式生成一个json文件，将该json文件传入分析工具<a href="chrome://tracing/">chrome://tracing/</a>生成火焰图，通过以下火焰图，我们可以非常方便的看到启动时执行了哪些方法和耗时的多少，接下来需要分析每个任务在启动时调用的必要性然后再针对其进行优化，以下为未优化时的火焰图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58ef65604f5?w=1240&h=609&f=png&s=119323"></p>
<p>从左到右为启动时间轴，从上到下为：方法A里面调用了方法B、C、D。方法A就在最上层，BCD就在下一层，例如APPDelegate的swizzied_didFinishLuanch方法里面调用了YYlaunch…和MainTabbarController。以此类推可以找到最终调用到了哪个方法导致的耗时。</p>
<h4 id="方案三：APP-Launch工具"><a href="#方案三：APP-Launch工具" class="headerlink" title="方案三：APP Launch工具"></a>方案三：APP Launch工具</h4><p>APP Launch工具是目前来说启动优化最强最全面的检测工具并且它也是苹果官方推荐的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/xcode/improving_your_app_s_performance/reducing_your_app_s_launch_time?language=objc">官方地址</a>，他同时包含了Time Profile 以及 System Trace的功能，火焰图只抓了主线程（可以抓其他线程，但是查看没这么方便）并且还有一些非常隐晦的耗时操作也没法抓获，直接使用这个工具来做启动优化也是完全可行的,简单介绍以下这个工具的用法：</p>
<ul>
<li>首先在Xcode的build settings 中Debug Information Format 设置为 DWARF with dsYM File (用于符号化地址)</li>
<li>Xcode编译运行项目</li>
<li>通过 Xcode –&gt; Open Developer Tool –&gt; Instruments –&gt; APP Launch 启动应用(这样可以直接运行debug包)，APPLaunch会启动应用5秒后自动关闭应用。</li>
<li>如果得到的分析数据没有符号化，在APP Launch选择屏幕左上角的file –&gt; Symbols 选择亮绿灯的符号, 重新在在APP Launch运行项目。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58ef297e7e1?w=1208&h=743&f=gif&s=2094229"></p>
<p>大概是上图的操作方式，得出主线程的所有任务耗时时间，每个任务根据图右侧的堆栈挨个排查是否是启动链路中可优化的（几毫秒的也别放过）。</p>
<h3 id="对找到的耗时任务进行修改"><a href="#对找到的耗时任务进行修改" class="headerlink" title="对找到的耗时任务进行修改"></a>对找到的耗时任务进行修改</h3><p>通过以上介绍的方案，可以找出可优化的任务，举几个可以借鉴优化的例子：</p>
<ol>
<li><p>懒加载/延后对应方法：在didFinishlanched方法较早的地方有挺多手动hook的方法，有一些是可以优化的，比如hook了路由的跳转，作用是启动之后在直播间相关组件没有初始化完成而执行进入直播间操作会导致异常，但是在启动时是没有路由操作的，这种hook可以延后到initialize方法第一次执行路由的时候。</p>
</li>
<li><p>预加载图片：通过app luanch的动态图最后停留的部分，可以得到有21ms（而火焰图统计的在45ms左右）的耗时是在tabitem设置图片的时候,总共5个tab，10张图片。耗时主要是来自 <code>imageNamed:</code> 的解码操作。这个可以优化吗？</p>
<p>由于imageNamed方法是有缓存机制的，并且它也是线程安全的，所以可以在一个更早的时机将启动需要的图片在子线程进行解码。通过hook imageNamed方法得到启动时候所需的本地图片，在一个较早的时机进行 <code>图片预加载</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 目前我们是在appdelegate的didFinshedLaunch方法内执行</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSArray *preloadImage &#x3D; @[@&quot;image1&quot;,@&quot;image2&quot;...];</span><br><span class="line">    for (NSString *imageName in preloadImage) &#123;</span><br><span class="line">        [UIImage imageNamed:imageName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 可以通过方案一的方式分别获取耗时来评估预加载是否有效，验证使用预加载之后耗时由40ms减少到了3ms</span><br><span class="line">- (void)setAllTabbarItems</span><br><span class="line">&#123;</span><br><span class="line">    CFAbsoluteTime start &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    [self setItemImage...];</span><br><span class="line">    NSLog(@&quot;setAllTabbarItems : %f&quot;,CFAbsoluteTimeGetCurrent() - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>还有一个容易忽略的点</strong>：我们的下拉刷新控件上面有一个图片动画组，进行解码也会很耗时，可以 <code>延后整个下拉刷新控件的设置</code> 到启动后而不是全部将图片丢到预加载。还有一些取数据库缓存、沙盒缓存的操作也可以提前到这个子线程预加载。</p>
<ol start="3">
<li><p>延后自动登录：自动登录成功之后会发一个通知，有的地方收到这个通知之后会有拉配置等耗时的操作，在启动过程中是不需要自动登录的（如果首页的请求需要传uid之类的可以先缓存），把<code>自动登录逻辑放在启动完成之后</code>。因为我们的自动登录方式比较隐蔽且触发地方较多，在自动登录的位置打个断点，运行程序看启动流程中哪些步骤会导致登录操作，对其进行优化。</p>
</li>
<li><p>预请求首页数据：通过火焰图分析，中间有两段较长时间主线程差不多处于空闲，是否可以优化？是因为主线程被其他线程挂起了吗？最终得出结论，是因为这时候在请求首页数据，等待数据渲染首页，首页的网络请求是在首页的viewdidload方法执行的，可以改到didFinishLaunchingWithOptions较早的时机<code>预请求首页数据</code>，缩短主线程空闲段的时间，在预请求的时候我们还要考虑一个网络资源竞争的问题，可以通过自定义的NSURLProtocol拦截找出启动时的所有NSURLSession请求，尽量保证首页的预请求为第一个请求，并且延后不必要的网络请求，我们有拦截到某sdk初始化时直接发了很多请求以及我们的IP直连相关逻辑，导致预请求首页的效果并不明显，（如何评估预请求效果？其实就是记录首页请求返回时时间点，然后减去main函数时间点得到从main–&gt;数据返回的时间差）修改ip直连以及sdk的请求之后，首页数据返回提前了150-200ms，而在iPhone8plus上本身启动就1s多，启动速度直接就提升了15%。其次还有因为我们的首页使父子控制器的构造，在当前显示的子控制器加载的时候会去预加载/渲染左右两边的控制器，在启动流程中将这个步骤延后到启动完成（这个耗时也比较高）。</p>
</li>
<li><p><code>缓存首页数据</code>:预请求可以提前数据返回时间，而使用缓存能直接去掉网络请求的耗时，常见的为先使用缓存再用请求的数据刷新界面，体验效果很差，如果直接就使用缓存则效果会很好，但是启动间隔太久会导致首页的主播大部分都已经下播了，于是我们给缓存设置了一个有效时期（目前定义为3-5分钟），如果本次启动距离上次缓存的数据时间相差不超过这个时期，则直接使用缓存，超过了则使用预加载的值。</p>
</li>
<li><p><code>首页分段式加载</code>:我们的首页主要结构分为顶部的搜索框，以及下面的数据快，显然更重要的是下面数据快的展示，于是可以延后搜索框的加载，不过因为影响不太大（20ms）然后产品对这个方案不太支持，就没上了，如果你的app有这种明显的多个段落，也可以优先保证重要的段先展示出来。</p>
<h3 id="APP-Launch-工具的威力"><a href="#APP-Launch-工具的威力" class="headerlink" title="APP Launch 工具的威力"></a>APP Launch 工具的威力</h3><p>做完以上的优化之后，我们再使用APP Launch工具检测一下是否有其他可优化的地方，这里使用了system trace相关的功能。在检测的数据内点击下图的三角形，展开应用的所有线程，然后找到主线程。</p>
</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58ef9ddfcf7?w=592&h=244&f=png&s=35077"><br><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f1dca6f9a?w=1240&h=751&f=png&s=463901" alt="appLaunch.png"></p>
<p>通过上图我们可以看到有一个等待锁的操作导致主线程被block了47ms（有时候测是80ms），我们需要找到原因然后处理它，比较简单的找的方式就是看看在主线程被block的这段时间，哪个子线程在执行任务，把工具检测到的线程都看一下，很容易就找到了某个子线程正在执行某个任务，而且存在中断-&gt;执行-&gt;中断这种反复调用中，我们对其进行修改，最终</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f1e2ce38b?w=648&h=82&f=png&s=34480"></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f267cd6a6?w=548&h=72&f=png&s=18773"></p>
<p>这段耗时<code>由188ms减少到了78ms</code>。其他的block也一并看了一下，系统行为无法调整。</p>
<h2 id="5、点击push启动优化"><a href="#5、点击push启动优化" class="headerlink" title="5、点击push启动优化"></a>5、点击push启动优化</h2><p>将启动任务分为了高、中、低三个优先级，其中高优先级是应用启动必须的，中优先级定义为进直播间、跳转页面必须的，低优先级为启动完成后执行的任务。</p>
<p>优化点击push进落地页，其实也就是用前面介绍的方法优化中优先级的任务,其次通过push进直播间时，用户是期望优先看到直播内容，由于首页的请求、加载和渲染会占用资源，所以可以在push进直播间的链路上，将首页的请求延后至从直播间退出的时候。</p>
<h2 id="6、二进制重排"><a href="#6、二进制重排" class="headerlink" title="6、二进制重排"></a>6、二进制重排</h2><p>二进制重排的原理：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f26e888ea?w=1240&h=695&f=png&s=604109"></p>
<p>通过APP Launch检测缺页中断次数，由于应用启动后会在内存有缓存，所以需要重启设备清空内存缓存来检测。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f31172856?w=1240&h=749&f=png&s=573801"></p>
<p>项目在编译生成二进制代码的时候，默认是按照链接的Object File(.o)顺序写文件，按照Object File内部的函数顺序写函数。<br>链接的顺序就是：build phases –&gt; Compile Sources 里面的顺序。可以通过xcode设置 Build Settings –&gt; Write Link Map File 为YES，生成Link map文件，然后在link map的# Symbols:段查看符号链接的顺序。</p>
<p>有了以上理论知识，我们实现二进制重排要做的就是在编译的时候，将启动需要的符号都排在一起，生成可执行文件，这样在分页加载到内存时尽量少的触发缺页中断。</p>
<ul>
<li>如何调整项目编译时的符号顺序？XCode使用的链接器叫做ld，ld有个参数叫order_file，只要有这个文件并将文件的路径告诉XCode，XCode编译的时候就会按照文件中的符号顺序打包二进制可执行文件。</li>
<li>如何获取启动时需要的符号？其实就是获取启动时调用的所有方法，clang有提供对应的2个API<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html">clang地址</a>，简单说就是在Other C falg 添加参数-fsanitize-coverage=func,trace-pc-guard,实现两个方法，__sanitizer_cov_trace_pc_guard_init，以及__sanitizer_cov_trace_pc_guard，第一个是初始化方法，第二个是每调用一个方法就会被拦截到，然后记录下启动时拦截到的所有方法，这样就获取到了启动时所需要的符号，将符号写入并生成order_file文件，在Build Settings –&gt;Order file将文件路径设置进去。</li>
</ul>
<p>之后可以通过分析linkmap的# Symbols:段确认符号是否有调整，确认有调整之后对成果进行检验：在iOS13 iPhone8plus上无论是检测的page fault次数/耗时，还是启动耗时，使用二进制重排与不使用相差很小很小，大概就是每次测量的波动范围内，不知道是否是iOS13 的dyld2升级到dyld3已经优化过了（有关dyld升级优化感兴趣可以自行搜索了解）。所以最终我们也是放弃了二进制重排。</p>
<h2 id="7、启动优化后续计划"><a href="#7、启动优化后续计划" class="headerlink" title="7、启动优化后续计划"></a>7、启动优化后续计划</h2><ol>
<li>启动模块化，目前所有的启动项都集中在一个类里面，光+import头文件就200行，所以在下个版本会将启动项按业务分成多个模块进行处理。</li>
<li>推动其他sdk进行优化，特别是子线程占用较多的需要控制一下线程数量，目前相关sdk也在处理中。</li>
</ol>
<h1 id="四、启动监控"><a href="#四、启动监控" class="headerlink" title="四、启动监控"></a>四、启动监控</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>为了可以监控到日常开发过程中启动耗时变化，监控了启动过程中的方法调用耗时，通过每天构建对比当天版本和昨天版本的差异分析耗时原因，流程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f42aaad5e?w=622&h=277&f=png&s=31682"></p>
<ul>
<li>Jenkins 编译构建，构建完成后，上报 LinkMap</li>
<li>打包完成后，通过 <code>ios-deploy</code>，真机安装 App</li>
<li>启动 <code>Appium</code>, 用于多次启动 App</li>
<li>运行测试脚本，通过控制 Appium, Appium 控制设备，重复冷启动多次，上报数据，取平均值，减少浮动影响</li>
<li>分析数据，耗时新增，减少，增加和 Diff 等</li>
<li>分析结果邮件发送</li>
<li>优化代码</li>
</ul>
<h2 id="分析报告"><a href="#分析报告" class="headerlink" title="分析报告"></a>分析报告</h2><p>第一部分是 <code>Pre-Main</code> 和 首页图片加载完成耗时, 如下:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f44f0a1ce?w=1240&h=103&f=png&s=36377"></p>
<p>第二部分是通过对比两个版本的启动耗时数据进行 Diff, 启动过程中，如果当前版本的方法在对比版本没有出现，就认为是新增方法</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f5dc261ac?w=1240&h=103&f=png&s=31766"></p>
<p>第三部分是已存在方法耗时变化</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f6b874bcb?w=1240&h=527&f=png&s=212788"></p>
<p>第四部分是库在启动过程中，占用的耗时</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f747c1fdb?w=1240&h=205&f=png&s=29543"></p>
<p>第五部分是 + load 方法，占用的耗时</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f782e2c77?w=1240&h=397&f=png&s=92486"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>通过 Hook 记录启动阶段方法和对应方法的耗时</p>
<h3 id="统计-Pre-Main-和首页图片加载完成耗时"><a href="#统计-Pre-Main-和首页图片加载完成耗时" class="headerlink" title="统计 Pre-Main 和首页图片加载完成耗时"></a>统计 Pre-Main 和首页图片加载完成耗时</h3><p>Pre-Main 耗时 = 进入 main 函数的时间 - 进程创建时间，以下是获取进程创建时间实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)processInfoForPID:(int)pid procInfo:(struct kinfo_proc *)procInfo &#123;</span><br><span class="line">    int cmd[4] &#x3D; &#123;CTL_KERN, KERN_PROC, KERN_PROC_PID, pid&#125;;</span><br><span class="line">    size_t size &#x3D; sizeof(*procInfo);</span><br><span class="line">    return sysctl(cmd, sizeof(cmd)&#x2F;sizeof(*cmd), procInfo, &amp;size, NULL, 0) &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSTimeInterval)processStartTime &#123;</span><br><span class="line">    struct kinfo_proc kProcInfo;</span><br><span class="line">    if ([self processInfoForPID:[[NSProcessInfo processInfo] processIdentifier] procInfo:&amp;kProcInfo]) &#123;</span><br><span class="line">        return kProcInfo.kp_proc.p_un.__p_starttime.tv_sec * 1000.0 + kProcInfo.kp_proc.p_un.__p_starttime.tv_usec &#x2F; 1000.0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSAssert(NO, @&quot;无法取得进程的信息&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首页图片加载完成耗时：Hook 图片下载方法，在启动完成前将所有调用该方法的 URL 存入数组，图片下载完成之后移除数组，当数组内元素个数为 0 时，代表首页第一屏的图片下载完成，即为结束时间</p>
<h3 id="Pre-Main-阶段的-load-方法、C-static-constructors-、-attribute-constructor-、-mod-init-func-section-中的函数和-OC-方法耗时统计"><a href="#Pre-Main-阶段的-load-方法、C-static-constructors-、-attribute-constructor-、-mod-init-func-section-中的函数和-OC-方法耗时统计" class="headerlink" title="Pre-Main 阶段的 + load 方法、C++ static constructors 、 attribute((constructor))、 __mod_init_func section 中的函数和 OC 方法耗时统计"></a>Pre-Main 阶段的 + load 方法、C++ static constructors 、 <strong>attribute</strong>((constructor))、 __mod_init_func section 中的函数和 OC 方法耗时统计</h3><h4 id="load"><a href="#load" class="headerlink" title="+ load"></a>+ load</h4><p>项目中的 <code>+ load</code> 方法或多或少对启动耗时有一定的影响，通过 <code>Hook + load</code> 方法，统计 <code>+ load</code> 方法耗时, 主要是通过一个比 + load 方法执行还要早的时机，对定义了 load 方法的类进行 Hook, 对 <code>load</code> 方法的前后插入统计耗时的处理</p>
<p><code>mach-o</code>  中 <code>__DATA,__objc_nlclslist</code> 和 <code>__DATA,__objc_nlcatlist</code> 这两个 <code>Section</code> 分别保存了 <code>non lazy class</code> 和 <code>non lazy cateogry</code>, 定义 load 方法的类和分类, 通过 <code>getsectbynamefromheader</code> 把定义了 load 方法的类和分类获取出来进行 Hook, 用最早加载的动态库里定义类的 <code>load</code> 方法，比主二进制的 <code>load</code> 方法调用还要早。通过在动态库中 <code>load</code> 方法这个时机进行 Hook</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f7ba58e7f?w=774&h=764&f=png&s=191079"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct Category &#123;</span><br><span class="line">    char * _Nonnull category_name;</span><br><span class="line">    char * _Nonnull class_name;</span><br><span class="line">    struct objc_method_list * _Nullable instance_methods;</span><br><span class="line">    struct objc_method_list * _Nullable class_methods;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 load 方法的类和分类</span><br><span class="line">const section *nonLazyClass &#x3D; GetSectByNameFromHeader((void *)mach_header, &quot;__DATA&quot;, &quot;__objc_nlclslist&quot;);</span><br><span class="line">if (NULL !&#x3D; nonLazyClass) &#123;</span><br><span class="line">    for (ptr address &#x3D; nonLazyClass-&gt;offset; address &lt; nonLazyClass-&gt;offset + nonLazyClass-&gt;size; address +&#x3D; sizeof(const void *)) &#123;</span><br><span class="line">        Class cls &#x3D; (__bridge Class)(*(void **)(mach_header + address));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">const section *nonLazyCategory &#x3D; GetSectByNameFromHeader((void *)mach_header, &quot;__DATA&quot;, &quot;__objc_nlcatlist&quot;);</span><br><span class="line">if (NULL !&#x3D; nonLazyCategory) &#123;</span><br><span class="line">    for (ptr address &#x3D; nonLazyCategory-&gt;offset; address &lt; nonLazyCategory-&gt;offset + nonLazyCategory-&gt;size; address +&#x3D; sizeof(const void **)) &#123;</span><br><span class="line">        struct Category *cat &#x3D; (*(struct Category **)(mach_header + address));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历 load class 和对应 category 的 MethodList 进行 Hook</span><br><span class="line">IMP originIMP &#x3D; loadMethod-&gt;imp;</span><br><span class="line">IMP replaceIMP &#x3D; imp_implementationWithBlock(^(__unsafe_unretained id self, SEL sel) &#123;</span><br><span class="line">    ((void (*)(id, SEL))originIMP)(self, sel);</span><br><span class="line">&#125;);</span><br><span class="line">loadMethod-&gt;imp &#x3D; replaceIMP;</span><br></pre></td></tr></table></figure>
<h4 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h4><p>OC 的方法执行过程会调用到 <code>objc_msgSend</code>, 所以对其进行 Hook，能统计到 OC 方法的耗时，<code>objc_msgSend</code> 是变参函数，通过保存现场，保持参数不变，调用原来的 objc_msgSend,  参考 <a target="_blank" rel="noopener" href="https://github.com/DavidGoldman/InspectiveC/blob/master/InspectiveCarm64.mm">InspectiveC</a> 实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">static void replacementObjc_msgSend() &#123;</span><br><span class="line">  __asm__ volatile (</span><br><span class="line">      &#x2F;&#x2F; 保存 q0-q7 </span><br><span class="line">      &quot;stp q6, q7, [sp, #-32]!\n&quot;</span><br><span class="line">      &quot;stp q4, q5, [sp, #-32]!\n&quot;</span><br><span class="line">      &quot;stp q2, q3, [sp, #-32]!\n&quot;</span><br><span class="line">      &quot;stp q0, q1, [sp, #-32]!\n&quot;</span><br><span class="line">      &#x2F;&#x2F; 保存 x0-x8, lr</span><br><span class="line">      &quot;stp x8, lr, [sp, #-16]!\n&quot;</span><br><span class="line">      &quot;stp x6, x7, [sp, #-16]!\n&quot;</span><br><span class="line">      &quot;stp x4, x5, [sp, #-16]!\n&quot;</span><br><span class="line">      &quot;stp x2, x3, [sp, #-16]!\n&quot;</span><br><span class="line">      &quot;stp x0, x1, [sp, #-16]!\n&quot;</span><br><span class="line">      &quot;mov x2, x1\n&quot;</span><br><span class="line">      &quot;mov x1, lr\n&quot;</span><br><span class="line">      &quot;mov x3, sp\n&quot;</span><br><span class="line">      &#x2F;&#x2F; 调用 preObjc_msgSend</span><br><span class="line">      &quot;bl __Z15preObjc_msgSendP11objc_objectmP13objc_selectorP9RegState_\n&quot;</span><br><span class="line">      &quot;mov x9, x0\n&quot;</span><br><span class="line">      &quot;mov x10, x1\n&quot;</span><br><span class="line">      &quot;tst x10, x10\n&quot;</span><br><span class="line">      &#x2F;&#x2F; 读取 x0-x8, lr</span><br><span class="line">      &quot;ldp x0, x1, [sp], #16\n&quot;</span><br><span class="line">      &quot;ldp x2, x3, [sp], #16\n&quot;</span><br><span class="line">      &quot;ldp x4, x5, [sp], #16\n&quot;</span><br><span class="line">      &quot;ldp x6, x7, [sp], #16\n&quot;</span><br><span class="line">      &quot;ldp x8, lr, [sp], #16\n&quot;</span><br><span class="line">      &#x2F;&#x2F; 读取 q0-q7</span><br><span class="line">      &quot;ldp q0, q1, [sp], #32\n&quot;</span><br><span class="line">      &quot;ldp q2, q3, [sp], #32\n&quot;</span><br><span class="line">      &quot;ldp q4, q5, [sp], #32\n&quot;</span><br><span class="line">      &quot;ldp q6, q7, [sp], #32\n&quot;</span><br><span class="line">      &quot;b.eq Lpassthrough\n&quot;</span><br><span class="line">      &#x2F;&#x2F; blr 调用原始 objc_msgSend</span><br><span class="line">      &quot;blr x9\n&quot;</span><br><span class="line">      &#x2F;&#x2F; 保存 x0-x9</span><br><span class="line">      &quot;stp x0, x1, [sp, #-16]!\n&quot;</span><br><span class="line">      &quot;stp x2, x3, [sp, #-16]!\n&quot;</span><br><span class="line">      &quot;stp x4, x5, [sp, #-16]!\n&quot;</span><br><span class="line">      &quot;stp x6, x7, [sp, #-16]!\n&quot;</span><br><span class="line">      &quot;stp x8, x9, [sp, #-16]!\n&quot;</span><br><span class="line">      &#x2F;&#x2F; 保存 q0-q7</span><br><span class="line">      &quot;stp q0, q1, [sp, #-32]!\n&quot;</span><br><span class="line">      &quot;stp q2, q3, [sp, #-32]!\n&quot;</span><br><span class="line">      &quot;stp q4, q5, [sp, #-32]!\n&quot;</span><br><span class="line">      &quot;stp q6, q7, [sp, #-32]!\n&quot;</span><br><span class="line">      &#x2F;&#x2F; 调用 postObjc_msgSend hook.</span><br><span class="line">      &quot;bl __Z16postObjc_msgSendv\n&quot;</span><br><span class="line">      &quot;mov lr, x0\n&quot;</span><br><span class="line">      &#x2F;&#x2F; 读取 q0-q7</span><br><span class="line">      &quot;ldp q6, q7, [sp], #32\n&quot;</span><br><span class="line">      &quot;ldp q4, q5, [sp], #32\n&quot;</span><br><span class="line">      &quot;ldp q2, q3, [sp], #32\n&quot;</span><br><span class="line">      &quot;ldp q0, q1, [sp], #32\n&quot;</span><br><span class="line">       &#x2F;&#x2F; 读取 x0-x9</span><br><span class="line">      &quot;ldp x8, x9, [sp], #16\n&quot;</span><br><span class="line">      &quot;ldp x6, x7, [sp], #16\n&quot;</span><br><span class="line">      &quot;ldp x4, x5, [sp], #16\n&quot;</span><br><span class="line">      &quot;ldp x2, x3, [sp], #16\n&quot;</span><br><span class="line">      &quot;ldp x0, x1, [sp], #16\n&quot;</span><br><span class="line">      &quot;ret\n&quot;</span><br><span class="line">      &quot;Lpassthrough:\n&quot;</span><br><span class="line">      &quot;br x9&quot;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-static-constructors-、-attribute-constructor-、-modinit-func-section-中的函数"><a href="#C-static-constructors-、-attribute-constructor-、-modinit-func-section-中的函数" class="headerlink" title="C++ static constructors 、 attribute((constructor))、 _modinit_func section 中的函数"></a>C++ static constructors 、 attribute((constructor))、 _modinit_func section 中的函数</h4><p><code>__mod_init_func</code> 存储初始化相关的函数地址, <code>__mod_init_func</code> 是在 DATA 段，Pointer 指向的区域是 TEXT 段, 项目中的这类函数很多，这些函数会在 Pre-Main 阶段执行，但是基本都不耗时, 通过 getsectiondata(machHeader, “__DATA”, “__mod_init_func”, &amp;size)，读取函数指针，用 hook 函数指针替换原来的函数指针，把原来的函数地址记录在全局数组中，hook 函数从数组中根据 index 调用本该执行的函数</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/19/172ca58f8027223a?w=1240&h=597&f=png&s=221234"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void myinit(int argc, char **argv, char **envp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((section(&quot;__DATA, __mod_init_func&quot;))) typeof(myinit) *__init &#x3D; myinit;</span><br><span class="line"></span><br><span class="line">YYTestClass test &#x3D; YYTestClass();</span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) void testConstructor() &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void HookInitFuncInitializer(int argc, const char *argv[], const char *envp[], const char *apple[], const struct ProgramVarsStr *vars) &#123;</span><br><span class="line">    ++CurrentPointerIndex;</span><br><span class="line">    InitializerType f &#x3D; (InitializerType)Initializer[CurrentPointerIndex];</span><br><span class="line">    f(argc, argv, envp, apple, vars);</span><br><span class="line">    </span><br><span class="line">    NSString *symbol &#x3D; [NSString stringWithFormat:@&quot;%p&quot;, f];</span><br><span class="line">    Dl_info info;</span><br><span class="line">    if (0 !&#x3D; dladdr(f, &amp;info)) &#123;</span><br><span class="line">        NSString *sname &#x3D; @(info.dli_sname);</span><br><span class="line">        if (sname.length &gt; 0) &#123;</span><br><span class="line">            symbol &#x3D; sname;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void HookModInitFunc() &#123;</span><br><span class="line">    Dl_info info;</span><br><span class="line">    dladdr(HookModInitFunc, &amp;info);</span><br><span class="line">    yy_mach_header *machHeader &#x3D; info.dli_fbase;</span><br><span class="line">    unsigned long size &#x3D; 0;</span><br><span class="line">    pointer *p &#x3D; (pointer *)getsectiondata(machHeader, &quot;__DATA&quot;, &quot;__mod_init_func&quot;, &amp;size);</span><br><span class="line">    int count &#x3D; (int)(size &#x2F; sizeof(void *));</span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; ++i) &#123;</span><br><span class="line">        pointer ptr &#x3D; p[i];</span><br><span class="line">        Initializer[i] &#x3D; ptr;</span><br><span class="line">        p[i] &#x3D; (pointer)HookInitFuncInitializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="库耗时统计"><a href="#库耗时统计" class="headerlink" title="库耗时统计"></a>库耗时统计</h4><p>LinkMap 中取到 Object files 部分，获取到 <code>libAFNetworking.a(AFHTTPSessionManager.o)</code> 部分，然后解析成 <code>AFNetworking</code> 和 <code>AFHTTPSessionManager</code>，通过这种方式能粗略的统计到是那个库，库里有包含的类，进而统计出那个方法属于该库，这个方法统计不到类的命名不对应文件名，或常见 Category 那些情况等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#x2F;Products&#x2F;Debug-iphoneos&#x2F;AFNetworking&#x2F;libAFNetworking.a(AFHTTPSessionManager.o)</span><br></pre></td></tr></table></figure>
<p>内容同事和我共同完成</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/30/Blog%20%E6%90%AC%E5%AE%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SylvanasX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/Blog%20%E6%90%AC%E5%AE%B6/" class="post-title-link" itemprop="url">Blog 搬家</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-30 11:07:50 / Modified: 14:17:22" itemprop="dateCreated datePublished" datetime="2021-01-30T11:07:50+08:00">2021-01-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SylvanasX</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SylvanasX</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
